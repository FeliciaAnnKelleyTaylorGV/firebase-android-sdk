mutation InsertStringVariants(
  $id: String!,
  $nonNullWithNonEmptyValue: String!,
  $nonNullWithEmptyValue: String!,
  $nullableWithNullValue: String,
  $nullableWithNonNullValue: String,
  $nullableWithEmptyValue: String,
  $emptyList: [String!],
  $nonEmptyList: [String!]
) @auth(level: PUBLIC) {
  stringVariants_insert(data: {
    id: $id,
    nonNullWithNonEmptyValue: $nonNullWithNonEmptyValue,
    nonNullWithEmptyValue: $nonNullWithEmptyValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    nullableWithEmptyValue: $nullableWithEmptyValue,
    emptyList: $emptyList,
    nonEmptyList: $nonEmptyList
  })
}

query GetStringVariantsById($id: String!) @auth(level: PUBLIC) {
  stringVariants(id: $id) {
    nonNullWithNonEmptyValue
    nonNullWithEmptyValue
    nullableWithNullValue
    nullableWithNonNullValue
    nullableWithEmptyValue
    emptyList
    nonEmptyList
  }
}

mutation InsertInt64Variants(
  $id: String!,
  $nonNullWithZeroValue: Int64!,
  $nonNullWithPositiveValue: Int64!,
  $nonNullWithNegativeValue: Int64!,
  $nonNullWithMaxValue: Int64!,
  $nonNullWithMinValue: Int64!,
  $nullableWithNullValue: Int64,
  $nullableWithZeroValue: Int64,
  $nullableWithPositiveValue: Int64,
  $nullableWithNegativeValue: Int64,
  $nullableWithMaxValue: Int64,
  $nullableWithMinValue: Int64,
  $emptyList: [Int64!],
  $nonEmptyList: [Int64!]
) @auth(level: PUBLIC) {
  int64Variants_insert(data: {
    id: $id,
    nonNullWithZeroValue: $nonNullWithZeroValue,
    nonNullWithPositiveValue: $nonNullWithPositiveValue,
    nonNullWithNegativeValue: $nonNullWithNegativeValue,
    nonNullWithMaxValue: $nonNullWithMaxValue,
    nonNullWithMinValue: $nonNullWithMinValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithZeroValue: $nullableWithZeroValue,
    nullableWithPositiveValue: $nullableWithPositiveValue,
    nullableWithNegativeValue: $nullableWithNegativeValue,
    nullableWithMaxValue: $nullableWithMaxValue,
    nullableWithMinValue: $nullableWithMinValue,
    emptyList: $emptyList,
    nonEmptyList: $nonEmptyList
  })
}

query GetInt64VariantsById($id: String!) @auth(level: PUBLIC) {
  int64Variants(id: $id) {
    nonNullWithZeroValue
    nonNullWithPositiveValue
    nonNullWithNegativeValue
    nonNullWithMaxValue
    nonNullWithMinValue
    nullableWithNullValue
    nullableWithZeroValue
    nullableWithPositiveValue
    nullableWithNegativeValue
    nullableWithMaxValue
    nullableWithMinValue
    emptyList
    nonEmptyList
  }
}

mutation InsertUUIDVariants(
  $id: String!,
  $nonNullValue: UUID!,
  $nullableWithNullValue: UUID,
  $nullableWithNonNullValue: UUID,
  $emptyList: [UUID!],
  $nonEmptyList: [UUID!]
) @auth(level: PUBLIC) {
  uUIDVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    emptyList: $emptyList,
    nonEmptyList: $nonEmptyList
  })
}

query GetUUIDVariantsById($id: String!) @auth(level: PUBLIC) {
  uUIDVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
    emptyList
    nonEmptyList
  }
}

mutation InsertTimestampVariants(
  $id: String!,
  $nonNullValue: Timestamp!,
  $nullableWithNullValue: Timestamp,
  $nullableWithNonNullValue: Timestamp,
  $minValue: Timestamp!,
  $maxValue: Timestamp!,
  $emptyList: [Timestamp!],
  $nonEmptyList: [Timestamp!]
) @auth(level: PUBLIC) {
  timestampVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    minValue: $minValue,
    maxValue: $maxValue,
    emptyList: $emptyList,
    nonEmptyList: $nonEmptyList
  })
}

query GetTimestampVariantsById($id: String!) @auth(level: PUBLIC) {
  timestampVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
    minValue
    maxValue
    emptyList
    nonEmptyList
  }
}

mutation InsertDateVariants(
  $id: String!,
  $nonNullValue: Date!,
  $nullableWithNullValue: Date,
  $nullableWithNonNullValue: Date,
  $minValue: Date!,
  $maxValue: Date!,
  $nonZeroTime: Date!,
  $emptyList: [Date!],
  $nonEmptyList: [Date!]
) @auth(level: PUBLIC) {
  dateVariants_insert(data: {
    id: $id,
    nonNullValue: $nonNullValue,
    nullableWithNullValue: $nullableWithNullValue,
    nullableWithNonNullValue: $nullableWithNonNullValue,
    minValue: $minValue,
    maxValue: $maxValue,
    nonZeroTime: $nonZeroTime,
    emptyList: $emptyList,
    nonEmptyList: $nonEmptyList
  })
}

query GetDateVariantsById($id: String!) @auth(level: PUBLIC) {
  dateVariants(id: $id) {
    nonNullValue
    nullableWithNullValue
    nullableWithNonNullValue
    minValue
    maxValue
    nonZeroTime
    emptyList
    nonEmptyList
  }
}

mutation InsertSyntheticId($value: String!) @auth(level: PUBLIC) {
  syntheticId_insert(data: { value: $value })
}

query GetSyntheticIdById($id: UUID!) @auth(level: PUBLIC) {
  syntheticId(id: $id) { id value }
}

mutation InsertPrimaryKeyIsString($id: String!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsString_insert(data: {
    id: $id,
    value: $value
  })
}

query GetPrimaryKeyIsStringByKey($key: PrimaryKeyIsString_Key!) @auth(level: PUBLIC) {
  primaryKeyIsString(key: $key) { id value }
}

mutation InsertPrimaryKeyIsUUID($id: UUID!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsUUID_insert(data: {
    id: $id,
    value: $value
  })
}

query GetPrimaryKeyIsUUIDByKey($key: PrimaryKeyIsUUID_Key!) @auth(level: PUBLIC) {
  primaryKeyIsUUID(key: $key) { id value }
}

mutation InsertPrimaryKeyIsInt($foo: Int!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Int only has a 32-bit
  # representation, increasing the likelihood of conflicts. In the unlikely case of an ID being
  # used that already exists, it will just be replaced. There is a minuscule chance that the test
  # that generated the conflicting ID is running concurrently, but that chance is so small that I'm
  # choosing to ignore it.
  primaryKeyIsInt_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsIntByKey($key: PrimaryKeyIsInt_Key!) @auth(level: PUBLIC) {
  primaryKeyIsInt(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsFloat($foo: Float!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Float values are generated
  # using a pseudo-random number generator, which has a non-zero chance of conflicts. In the
  # unlikely case of an value being used that already exists, it will just be replaced. There is a
  # minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsFloat_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsFloatByKey($key: PrimaryKeyIsFloat_Key!) @auth(level: PUBLIC) {
  primaryKeyIsFloat(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsDate($foo: Date!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Date values are generated
  # using a pseudo-random number generator, which has a non-zero chance of conflicts. In the
  # unlikely case of an value being used that already exists, it will just be replaced. There is a
  # minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsDate_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsDateByKey($key: PrimaryKeyIsDate_Key!) @auth(level: PUBLIC) {
  primaryKeyIsDate(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsTimestamp($foo: Timestamp!, $value: String!) @auth(level: PUBLIC) {
  # NOTE: Use "upsert" instead of "insert" in this specific case since Timestamp values are
  # generated using a pseudo-random number generator, which has a non-zero chance of conflicts. In
  # the unlikely case of an value being used that already exists, it will just be replaced. There is
  # a minuscule chance that the test that generated the conflicting ID is running concurrently, but
  # that chance is so small that I'm choosing to ignore it.
  primaryKeyIsTimestamp_upsert(data: {
    foo: $foo,
    value: $value
  })
}

query GetPrimaryKeyIsTimestampByKey($key: PrimaryKeyIsTimestamp_Key!) @auth(level: PUBLIC) {
  primaryKeyIsTimestamp(key: $key) { foo value }
}

mutation InsertPrimaryKeyIsComposite($foo: Int!, $bar: String!, $baz: Boolean!, $value: String!) @auth(level: PUBLIC) {
  primaryKeyIsComposite_insert(data: {
    foo: $foo,
    bar: $bar,
    baz: $baz,
    value: $value
  })
}

query GetPrimaryKeyIsCompositeByKey($key: PrimaryKeyIsComposite_Key!) @auth(level: PUBLIC) {
  primaryKeyIsComposite(key: $key) { foo bar baz value }
}

mutation InsertNested1(
    $nested1: Nested1_Key,
    $nested2: Nested2_Key!,
    $nested2NullableNonNull: Nested2_Key,
    $nested2NullableNull: Nested2_Key,
    $value: String!
) @auth(level: PUBLIC) {
  nested1_insert(data: {
    nested1: $nested1,
    nested2: $nested2,
    nested2NullableNonNull: $nested2NullableNonNull,
    nested2NullableNull: $nested2NullableNull,
    value: $value
  })
}

query GetNested1ByKey($key: Nested1_Key!) @auth(level: PUBLIC) {
  nested1(key: $key) {
    id
    nested1 {
      id
      nested1 { id }
      nested2 {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
      nested2NullableNull {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
      nested2NullableNonNull {
        id
        value
        nested3 {
          id
          value
        }
        nested3NullableNull {
          id
          value
        }
        nested3NullableNonNull {
          id
          value
        }
      }
    }
    nested2 {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
    nested2NullableNonNull {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
    nested2NullableNull {
      id
      value
      nested3 {
        id
        value
      }
      nested3NullableNull {
        id
        value
      }
      nested3NullableNonNull {
        id
        value
      }
    }
  }
}

mutation InsertNested2(
    $nested3: Nested3_Key!,
    $nested3NullableNonNull: Nested3_Key,
    $nested3NullableNull: Nested3_Key,
    $value: String!
) @auth(level: PUBLIC) {
  nested2_insert(data: {
    nested3: $nested3,
    nested3NullableNonNull: $nested3NullableNonNull,
    nested3NullableNull: $nested3NullableNull,
    value: $value
  })
}

mutation InsertNested3($value: String!) @auth(level: PUBLIC) {
  nested3_insert(data: { value: $value })
}
